{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState } from \"react\";\nimport axios from \"axios\";\n\n// Create the Axios instance with base URL for Discogs API\nconst api = axios.create({\n  baseURL: 'https://api.discogs.com'\n});\n\n// Rate limiting variables\nlet lastRequestTime = 0;\nconst MIN_REQUEST_INTERVAL = 1000; // 1 second between requests\n\n// Rate limiting function\nconst rateLimit = async () => {\n  const now = Date.now();\n  const timeSinceLastRequest = now - lastRequestTime;\n  if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {\n    const delay = MIN_REQUEST_INTERVAL - timeSinceLastRequest;\n    console.log(`Rate limiting: waiting ${delay}ms before next request`);\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n  lastRequestTime = Date.now();\n};\n\n// Add token interceptor\napi.interceptors.request.use(async config => {\n  // Apply rate limiting before each request\n  await rateLimit();\n  const token = 'sgSOwNnDMKJCOWpLLTdNccwHTAbGVrUZOXjLcqxl';\n  if (token) {\n    config.params = {\n      ...config.params,\n      // Retain existing params, if any\n      token: token // Add the token as a query parameter\n    };\n  }\n  return config;\n}, error => Promise.reject(error));\n\n// Custom hook to interact with Discogs API\nexport const useDiscogs = () => {\n  _s();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Function to handle rate limit errors\n  const handleRateLimitError = async (error, retryCount = 0) => {\n    var _error$response;\n    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429 && retryCount < 3) {\n      const retryDelay = Math.pow(2, retryCount) * 1000; // Exponential backoff\n      console.log(`Rate limited. Retrying in ${retryDelay}ms (attempt ${retryCount + 1}/3)`);\n      await new Promise(resolve => setTimeout(resolve, retryDelay));\n      return true; // Indicate retry should happen\n    }\n    return false; // Don't retry\n  };\n\n  // Function to GET data\n  const getData = async endpoint => {\n    setLoading(true);\n    setError(null);\n    let retryCount = 0;\n    while (retryCount < 3) {\n      try {\n        const response = await api.get(endpoint);\n        return response.data;\n      } catch (err) {\n        const shouldRetry = await handleRateLimitError(err, retryCount);\n        if (shouldRetry) {\n          retryCount++;\n          continue;\n        }\n        setError(err);\n        console.error(\"Error fetching data:\", err);\n        throw err;\n      }\n    }\n    setLoading(false);\n  };\n\n  // Function to PUT (update) data\n  const putData = async (endpoint, data = {}) => {\n    setLoading(true);\n    setError(null);\n    let retryCount = 0;\n    while (retryCount < 3) {\n      try {\n        const response = await api.put(endpoint, data);\n        return response.data;\n      } catch (err) {\n        const shouldRetry = await handleRateLimitError(err, retryCount);\n        if (shouldRetry) {\n          retryCount++;\n          continue;\n        }\n        setError(err);\n        console.error(\"Error updating data:\", err);\n        throw err;\n      }\n    }\n    setLoading(false);\n  };\n\n  // Function to POST data\n  const postData = async (endpoint, data) => {\n    setLoading(true);\n    setError(null);\n    let retryCount = 0;\n    while (retryCount < 3) {\n      try {\n        const response = await api.post(endpoint, data);\n        return response.data;\n      } catch (err) {\n        const shouldRetry = await handleRateLimitError(err, retryCount);\n        if (shouldRetry) {\n          retryCount++;\n          continue;\n        }\n        setError(err);\n        console.error(\"Error posting data:\", err);\n        throw err;\n      }\n    }\n    setLoading(false);\n  };\n\n  // Function to DELETE data\n  const deleteData = async endpoint => {\n    setLoading(true);\n    setError(null);\n    let retryCount = 0;\n    while (retryCount < 3) {\n      try {\n        const response = await api.delete(endpoint);\n        return response.data;\n      } catch (err) {\n        const shouldRetry = await handleRateLimitError(err, retryCount);\n        if (shouldRetry) {\n          retryCount++;\n          continue;\n        }\n        setError(err);\n        console.error(\"Error deleting data:\", err);\n        throw err;\n      }\n    }\n    setLoading(false);\n  };\n  return {\n    getData,\n    postData,\n    deleteData,\n    putData,\n    loading,\n    error\n  };\n};\n_s(useDiscogs, \"Iz3ozxQ+abMaAIcGIvU8cKUcBeo=\");","map":{"version":3,"names":["useState","axios","api","create","baseURL","lastRequestTime","MIN_REQUEST_INTERVAL","rateLimit","now","Date","timeSinceLastRequest","delay","console","log","Promise","resolve","setTimeout","interceptors","request","use","config","token","params","error","reject","useDiscogs","_s","loading","setLoading","setError","handleRateLimitError","retryCount","_error$response","response","status","retryDelay","Math","pow","getData","endpoint","get","data","err","shouldRetry","putData","put","postData","post","deleteData","delete"],"sources":["/Users/peytonhollenback/Cod3/Multi-Frontend-Discogs-Helper/react-front/src/utility/dataSource.js"],"sourcesContent":["import { useState } from \"react\";\nimport axios from \"axios\";\n\n// Create the Axios instance with base URL for Discogs API\nconst api = axios.create({\n    baseURL: 'https://api.discogs.com'\n});\n\n// Rate limiting variables\nlet lastRequestTime = 0;\nconst MIN_REQUEST_INTERVAL = 1000; // 1 second between requests\n\n// Rate limiting function\nconst rateLimit = async () => {\n    const now = Date.now();\n    const timeSinceLastRequest = now - lastRequestTime;\n    \n    if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {\n        const delay = MIN_REQUEST_INTERVAL - timeSinceLastRequest;\n        console.log(`Rate limiting: waiting ${delay}ms before next request`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    \n    lastRequestTime = Date.now();\n};\n\n// Add token interceptor\napi.interceptors.request.use(\n    async (config) => {\n        // Apply rate limiting before each request\n        await rateLimit();\n        \n        const token = 'sgSOwNnDMKJCOWpLLTdNccwHTAbGVrUZOXjLcqxl';\n        if (token) {\n            config.params = {\n                ...config.params, // Retain existing params, if any\n                token: token      // Add the token as a query parameter\n            };\n        }\n        return config;\n    },\n    (error) => Promise.reject(error)\n);\n\n// Custom hook to interact with Discogs API\nexport const useDiscogs = () => {\n    const [loading, setLoading] = useState(false);\n    const [error, setError] = useState(null);\n\n    // Function to handle rate limit errors\n    const handleRateLimitError = async (error, retryCount = 0) => {\n        if (error.response?.status === 429 && retryCount < 3) {\n            const retryDelay = Math.pow(2, retryCount) * 1000; // Exponential backoff\n            console.log(`Rate limited. Retrying in ${retryDelay}ms (attempt ${retryCount + 1}/3)`);\n            await new Promise(resolve => setTimeout(resolve, retryDelay));\n            return true; // Indicate retry should happen\n        }\n        return false; // Don't retry\n    };\n\n    // Function to GET data\n    const getData = async (endpoint) => {\n        setLoading(true);\n        setError(null);\n        let retryCount = 0;\n        \n        while (retryCount < 3) {\n            try {\n                const response = await api.get(endpoint);\n                return response.data;\n            } catch (err) {\n                const shouldRetry = await handleRateLimitError(err, retryCount);\n                if (shouldRetry) {\n                    retryCount++;\n                    continue;\n                }\n                setError(err);\n                console.error(\"Error fetching data:\", err);\n                throw err;\n            }\n        }\n        setLoading(false);\n    };\n\n    // Function to PUT (update) data\n    const putData = async (endpoint, data = {}) => {\n        setLoading(true);\n        setError(null);\n        let retryCount = 0;\n        \n        while (retryCount < 3) {\n            try {\n                const response = await api.put(endpoint, data);\n                return response.data;\n            } catch (err) {\n                const shouldRetry = await handleRateLimitError(err, retryCount);\n                if (shouldRetry) {\n                    retryCount++;\n                    continue;\n                }\n                setError(err);\n                console.error(\"Error updating data:\", err);\n                throw err;\n            }\n        }\n        setLoading(false);\n    };\n\n    // Function to POST data\n    const postData = async (endpoint, data) => {\n        setLoading(true);\n        setError(null);\n        let retryCount = 0;\n        \n        while (retryCount < 3) {\n            try {\n                const response = await api.post(endpoint, data);\n                return response.data;\n            } catch (err) {\n                const shouldRetry = await handleRateLimitError(err, retryCount);\n                if (shouldRetry) {\n                    retryCount++;\n                    continue;\n                }\n                setError(err);\n                console.error(\"Error posting data:\", err);\n                throw err;\n            }\n        }\n        setLoading(false);\n    };\n\n    // Function to DELETE data\n    const deleteData = async (endpoint) => {\n        setLoading(true);\n        setError(null);\n        let retryCount = 0;\n        \n        while (retryCount < 3) {\n            try {\n                const response = await api.delete(endpoint);\n                return response.data;\n            } catch (err) {\n                const shouldRetry = await handleRateLimitError(err, retryCount);\n                if (shouldRetry) {\n                    retryCount++;\n                    continue;\n                }\n                setError(err);\n                console.error(\"Error deleting data:\", err);\n                throw err;\n            }\n        }\n        setLoading(false);\n    };\n\n    return {\n        getData,\n        postData,\n        deleteData,\n        putData,\n        loading,\n        error,\n    };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}